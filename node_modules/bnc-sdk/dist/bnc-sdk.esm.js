import SturdyWebSocket from 'sturdy-websocket';
import CryptoEs from 'crypto-es';
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function createEmitter() {
  return {
    listeners: {},
    on: function (eventCode, listener) {
      // check if valid eventCode
      switch (eventCode) {
        case 'txSent':
        case 'txPool':
        case 'txConfirmed':
        case 'txSpeedUp':
        case 'txCancel':
        case 'txFailed':
        case 'all':
          break;

        default:
          throw new Error(eventCode + " is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/sdk");
      } // check that listener is a function


      if (typeof listener !== 'function') {
        throw new Error('Listener must be a function');
      } // add listener for the eventCode


      this.listeners[eventCode] = listener;
    },
    emit: function (state) {
      if (this.listeners[state.eventCode]) {
        return this.listeners[state.eventCode](state);
      }

      if (this.listeners.all) {
        return this.listeners.all(state);
      }
    }
  };
}

function networkName(id) {
  switch (id) {
    case 1:
      return 'main';

    case 3:
      return 'ropsten';

    case 4:
      return 'rinkeby';

    case 5:
      return 'goerli';

    case 42:
      return 'kovan';

    default:
      return 'local';
  }
}

function serverEcho(eventCode) {
  switch (eventCode) {
    case 'txRequest':
    case 'nsfFail':
    case 'txRepeat':
    case 'txAwaitingApproval':
    case 'txConfirmReminder':
    case 'txSendFail':
    case 'txError':
    case 'txUnderPriced':
    case 'txSent':
      return true;

    default:
      return false;
  }
}

function last(arr) {
  return arr.reverse()[0];
}

function validateType(options) {
  var name = options.name,
      value = options.value,
      type = options.type,
      optional = options.optional,
      customValidation = options.customValidation;

  if (!optional && typeof value === 'undefined') {
    throw new Error("\"" + name + "\" is required");
  }

  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {
    throw new Error("\"" + name + "\" must be of type: " + type + ", received type: " + typeof value + " from value: " + value);
  }

  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {
    throw new Error("\"" + value + "\" is not a valid \"" + name + "\"");
  }
}

function validateOptions(options) {
  validateType({
    name: 'sdk options',
    value: options,
    type: 'object'
  });
  var dappId = options.dappId,
      name = options.name,
      networkId = options.networkId,
      transactionHandlers = options.transactionHandlers,
      apiUrl = options.apiUrl,
      ws = options.ws;
  validateType({
    name: 'dappId',
    value: dappId,
    type: 'string'
  });
  validateType({
    name: 'name',
    value: name,
    type: 'string',
    optional: true
  });
  validateType({
    name: 'networkId',
    value: networkId,
    type: 'number'
  });
  validateType({
    name: 'transactionHandler',
    value: transactionHandlers,
    type: 'array',
    optional: true
  });

  if (transactionHandlers) {
    transactionHandlers.forEach(function (handler) {
      return validateType({
        name: 'transactionHandler',
        value: handler,
        type: 'function'
      });
    });
  }

  validateType({
    name: 'apiUrl',
    value: apiUrl,
    type: 'string',
    optional: true
  });
  validateType({
    name: 'ws',
    value: ws,
    type: 'function',
    optional: true
  });
}

function validateTransaction(hash, id) {
  validateType({
    name: 'hash',
    value: hash,
    type: 'string',
    customValidation: validTxHash
  });
  validateType({
    name: 'id',
    value: id,
    type: 'string',
    optional: true
  });
}

function validateAccount(address) {
  validateType({
    name: 'address',
    value: address,
    type: 'string'
  });
}

function validateUnsubscribe(addressOrHash) {
  validateType({
    name: 'addressOrHash',
    value: addressOrHash,
    type: 'string'
  });
}

function validateEvent(eventObj) {
  validateType({
    name: 'eventObj',
    value: eventObj,
    type: 'object'
  });
  var eventCode = eventObj.eventCode,
      categoryCode = eventObj.categoryCode,
      transaction = eventObj.transaction,
      wallet = eventObj.wallet,
      contract = eventObj.contract;
  validateType({
    name: 'eventCode',
    value: eventCode,
    type: 'string'
  });
  validateType({
    name: 'categoryCode',
    value: categoryCode,
    type: 'string'
  });
  validateType({
    name: 'transaction',
    value: transaction,
    type: 'object',
    optional: true
  });

  if (transaction) {
    var id = transaction.id,
        to = transaction.to,
        from = transaction.from,
        value = transaction.value,
        gas = transaction.gas,
        gasPrice = transaction.gasPrice,
        nonce = transaction.nonce,
        status_1 = transaction.status,
        startTime = transaction.startTime;
    validateType({
      name: 'id',
      value: id,
      type: 'string',
      optional: true
    });
    validateType({
      name: 'to',
      value: to,
      type: 'string',
      optional: true,
      customValidation: isAddress
    });
    validateType({
      name: 'from',
      value: from,
      type: 'string',
      optional: true,
      customValidation: isAddress
    });
    validateType({
      name: 'value',
      value: value,
      type: 'string',
      optional: true
    });
    validateType({
      name: 'gas',
      value: gas,
      type: 'string',
      optional: true
    });
    validateType({
      name: 'gasPrice',
      value: gasPrice,
      type: 'string',
      optional: true
    });
    validateType({
      name: 'nonce',
      value: nonce,
      type: 'number',
      optional: true
    });
    validateType({
      name: 'status',
      value: status_1,
      type: 'string',
      optional: true
    });
    validateType({
      name: 'startTime',
      value: startTime,
      type: 'number',
      optional: true
    });
  }

  validateType({
    name: 'wallet',
    value: wallet,
    type: 'object',
    optional: true
  });

  if (wallet) {
    var balance = wallet.balance;
    validateType({
      name: 'balance',
      value: balance,
      type: 'string',
      optional: true
    });
  }

  validateType({
    name: 'contract',
    value: contract,
    type: 'object',
    optional: true
  });

  if (contract) {
    var methodName = contract.methodName,
        parameters = contract.parameters;
    validateType({
      name: 'methodName',
      value: methodName,
      type: 'string',
      optional: true
    });
    validateType({
      name: 'parameters',
      value: parameters,
      type: 'array',
      optional: true
    });
  }
}

function isAddress(address) {
  return /^(0x)?[0-9a-fA-F]{40}$/.test(address);
}

function validTxHash(hash) {
  return /^0x([A-Fa-f0-9]{64})$/.test(hash);
}

function transaction(hash, id) {
  validateTransaction(hash, id); // create startTime for transaction

  var startTime = Date.now(); // create emitter for transaction

  var emitter = createEmitter(); // create eventCode for transaction

  var eventCode = 'txSent'; // put in queue

  this._watchedTransactions.push({
    hash: hash,
    emitter: emitter
  });

  var transaction = {
    hash: hash,
    id: id || hash,
    startTime: startTime,
    status: 'sent'
  };

  var newState = __assign(__assign({}, transaction), {
    eventCode: eventCode
  }); // logEvent to server


  this._sendMessage({
    eventCode: eventCode,
    categoryCode: 'activeTransaction',
    transaction: transaction
  });

  var transactionObj = {
    details: transaction,
    emitter: emitter
  };

  function emitState() {
    var emitterResult = emitter.emit(newState);

    this._transactionHandlers.forEach(function (handler) {
      return handler({
        transaction: newState,
        emitterResult: emitterResult
      });
    });
  } // emit after delay to allow for listener to be registered


  setTimeout(emitState.bind(this), 5);
  return transactionObj;
}

function account(address) {
  validateAccount(address); // lowercase the address

  address = address.toLowerCase(); // create emitter for transaction

  var emitter = createEmitter(); // create eventCode for transaction

  var eventCode = 'accountAddress';

  var existingAddressWatcher = this._watchedAccounts.find(function (ac) {
    return ac.address === address;
  });

  if (existingAddressWatcher) {
    // add to existing emitters array
    existingAddressWatcher.emitters.push(emitter);
  } else {
    // put in accounts queue
    this._watchedAccounts.push({
      address: address,
      emitters: [emitter]
    });
  } // logEvent to server


  this._sendMessage({
    eventCode: eventCode,
    categoryCode: 'watch',
    account: {
      address: address
    }
  });

  return {
    emitter: emitter,
    details: {
      address: address
    }
  };
}

function event(eventObj) {
  validateEvent(eventObj);

  this._sendMessage(eventObj);
}

function unsubscribe(addressOrHash) {
  validateUnsubscribe(addressOrHash);

  if (isAddress(addressOrHash)) {
    var normalizedAddress = addressOrHash.toLowerCase(); // remove address from accounts

    this._watchedAccounts = this._watchedAccounts.filter(function (ac) {
      return ac.address !== addressOrHash;
    }); // logEvent to server

    this._sendMessage({
      eventCode: 'accountAddress',
      categoryCode: 'unwatch',
      account: {
        address: normalizedAddress
      }
    });
  } else if (validTxHash(addressOrHash)) {
    // remove transaction from transactions
    this._watchedTransactions = this._watchedTransactions.filter(function (tx) {
      return tx.hash !== addressOrHash;
    }); // logEvent to server

    this._sendMessage({
      eventCode: 'activeTransaction',
      categoryCode: 'unwatch',
      transaction: {
        hash: addressOrHash,
        id: addressOrHash,
        status: 'unsubscribed'
      }
    });
  } else {
    throw new Error("Error trying to unsubscribe " + addressOrHash + ": not a valid address or transaction hash");
  }
}

var version = "2.0.0";

function sendMessage(msg) {
  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          if (!!this._connected) return [3
          /*break*/
          , 2];
          return [4
          /*yield*/
          , waitForConnectionOpen.bind(this)()];

        case 1:
          _a.sent();

          _a.label = 2;

        case 2:
          this._socket.send(createEventLog.bind(this)(msg));

          return [2
          /*return*/
          ];
      }
    });
  });
}

function waitForConnectionOpen() {
  var _this = this;

  return new Promise(function (resolve) {
    var interval = setInterval(function () {
      if (_this._connected) {
        setTimeout(resolve, 100);
        clearInterval(interval);
      }
    });
  });
}

function handleMessage(msg) {
  var _a = JSON.parse(msg.data),
      status = _a.status,
      reason = _a.reason,
      event = _a.event,
      connectionId = _a.connectionId;

  if (connectionId) {
    if (typeof window !== 'undefined') {
      window.localStorage.setItem(this._storageKey, connectionId);
    }

    this._connectionId = connectionId;
  } // handle any errors from the server


  if (status === 'error') {
    if (reason.includes('not a valid API key')) {
      var errorObj = new Error(reason);
      throw errorObj;
    }

    if (reason.includes('network not supported')) {
      var errorObj = new Error(reason);
      throw errorObj;
    }

    if (reason.includes('maximum allowed amount')) {
      var errorObj = new Error(reason);
      throw errorObj;
    }
  }

  if (event && event.transaction) {
    var transaction_1 = event.transaction,
        eventCode = event.eventCode,
        contractCall = event.contractCall; // flatten in to one object

    var newState_1 = __assign(__assign({}, transaction_1), {
      eventCode: eventCode,
      contractCall: contractCall
    }); // ignore server echo and unsubscribe messages


    if (serverEcho(eventCode) || transaction_1.status === 'unsubscribed') {
      return;
    } // handle change of hash in speedup and cancel events


    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {
      this._watchedTransactions = this._watchedTransactions.map(function (tx) {
        if (tx.hash === transaction_1.originalHash) {
          // reassign hash parameter in transaction queue to new hash
          tx.hash = transaction_1.hash;
        }

        return tx;
      });
    }

    var watchedAddress_1 = transaction_1.watchedAddress && transaction_1.watchedAddress.toLowerCase();

    if (watchedAddress_1) {
      var accountObj = this._watchedAccounts.find(function (ac) {
        return ac.address === watchedAddress_1;
      });

      var emitterResult_1 = accountObj ? last(accountObj.emitters.map(function (emitter) {
        return emitter.emit(newState_1);
      })) : false;

      this._transactionHandlers.forEach(function (handler) {
        return handler({
          transaction: newState_1,
          emitterResult: emitterResult_1
        });
      });
    } else {
      var transactionObj = this._watchedTransactions.find(function (tx) {
        return tx.hash === transaction_1.hash;
      });

      var emitterResult_2 = transactionObj && transactionObj.emitter.emit(newState_1);

      this._transactionHandlers.forEach(function (handler) {
        return handler({
          transaction: newState_1,
          emitterResult: emitterResult_2
        });
      });
    }
  }
}

function createEventLog(msg) {
  return JSON.stringify(__assign({
    timeStamp: new Date(),
    dappId: this._dappId,
    version: version,
    blockchain: {
      system: 'ethereum',
      network: networkName(this._networkId)
    }
  }, msg));
}

var DEFAULT_NAME = 'unknown';

var Blocknative =
/** @class */
function () {
  function Blocknative(options) {
    validateOptions(options);
    var dappId = options.dappId,
        _a = options.name,
        name = _a === void 0 ? DEFAULT_NAME : _a,
        networkId = options.networkId,
        _b = options.transactionHandlers,
        transactionHandlers = _b === void 0 ? [] : _b,
        apiUrl = options.apiUrl,
        ws = options.ws;
    var socket = new SturdyWebSocket(apiUrl || 'wss://api.blocknative.com/v0', ws ? {
      wsConstructor: ws
    } : {});
    socket.onopen = onOpen.bind(this);
    socket.ondown = onDown.bind(this);
    socket.onreopen = onReopen.bind(this);
    socket.onmessage = handleMessage.bind(this);
    var storageKey = CryptoEs.SHA1(dappId + " - " + name).toString();
    var storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);
    this._storageKey = storageKey;
    this._connectionId = storedConnectionId || undefined;
    this._dappId = dappId;
    this._networkId = networkId;
    this._transactionHandlers = transactionHandlers;
    this._socket = socket;
    this._connected = false;
    this._sendMessage = sendMessage.bind(this);
    this._watchedTransactions = [];
    this._watchedAccounts = []; // public API

    this.transaction = transaction.bind(this);
    this.account = account.bind(this);
    this.event = event.bind(this);
    this.unsubscribe = unsubscribe.bind(this);
  }

  return Blocknative;
}();

function onOpen() {
  this._connected = true;

  this._sendMessage({
    categoryCode: 'initialize',
    eventCode: 'checkDappId',
    connectionId: this._connectionId
  });
}

function onDown() {
  this._connected = false;
}

function onReopen() {
  var _this = this;

  this._connected = true;

  this._sendMessage({
    categoryCode: 'initialize',
    eventCode: 'checkDappId',
    connectionId: this._connectionId
  }); // re-register all accounts to be watched by server upon
  // re-connection as they don't get transferred over automatically
  // to the new connection like tx hashes do


  this._watchedAccounts.forEach(function (account) {
    _this._sendMessage({
      eventCode: 'accountAddress',
      categoryCode: 'watch',
      account: {
        address: account.address
      }
    });
  });
}

export default Blocknative;
